# 面试经验

## 面试题目

```cpp
1. 进程之间的调度方式；
   操作系统中进程调度策略有哪几种方式
   1. 先来先服务算法
   		算法总是把处理机分配给最先进入就绪队列的进程，一个进程一旦分得处理机，便一直执行下去，直到该进程完成或阻塞时，才释放处理机。
   2. 时间片轮转
    	系统将所有就绪进程按FIFO规则排队，按一定的时间间隔把处理机分配给队列中的进程。这样，就绪队列中所有进程均可获得一个时间片的处理机而运行。
   3. 短作业优先(短进程)
    	该算法从就绪队列中选出下一个“CPU执行期最短”的进程，为之分配处理机，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。
    	该算法虽可获得较好的调度性能，但难以准确地知道下一个CPU执行期，而只能根据每一个进程的执行历史来预测。
   4. 高优先权优先调度算法
    	当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存。当用于进程调度时，该算法是把处理机分配给就绪队列中优先权最高的进程，这时，又可进一步把该算法分成如下两种:
		**非抢占式优先权算法:
			统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；或因发生某事件使该进程放弃处理机时，系统方可再将处理机重新分配给另一优先权最高的进程。这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中
		**抢占式优先权调度算法:
			在这种方式下，系统同样是把处理机分配给优先权最高的进程，使之执行。但在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程(原优先权最高的进程)的执行，重新将处理机分配给新到的优先权最高的进程,故而常用于要求比较严格的实时系统中;
			**容易出现优先级倒置现象
            	优先级反转指的是低优先级的任务持有高优先级任务的共享资源，高优先级的任务由于因为资源匮乏处于受阻的状态，一直等到低优先级的任务释放共享资源为止，而低优先级任务获取的cpu的时间少，如果此时有优先级处于两者之间的任务，并且不需要那个共享资源，则该中优先级的任务反而超过这两者获得更多的cpu执行时间，如果高优先级等待资源时不是阻塞等待，而是忙循环，则可能永远无法获得资源，因此此时低优先级的任务无法与高优先级的任务争夺CPU时间，从而无法执行，进而无法释放资源，造成的后果是就是高优先级的任务无法获得资源继续推进；
        	**优先级倒置的解决方案
                1. 优先级继承
                	当发现高优先级的任务因为低优先级任务占用共享资源而阻塞时，就将低优先级任务的优先级提升到占用共享资源的最高优先级任务的同等优先级
                2.　优先级天花板
                	优先级天花板指的是将申请某资源的任务的优先级提升可能访问该共享资源的所有任务中最高优先级任务的优先级；
                两者的区别：
                	优先级继承：只有一个任务访问资源时一切照旧，没有区别，只有当高优先级任务因为资源被低优先级占有而被阻塞时,才会提高占有资源任务的优先级；而优先级天花板,不论是否发生阻塞,都提升,即谁先拿到资源，就将这个任务提升到该资源的天花板优先级
            
    	
   5. 高响应比优先调度算法
    	在批处理系统中，短作业优先算法是一种比较好的算法，其主要的不足之处是长作业的运行得不到保证。如果我们能为每个作业引入前面所述的动态优先权，并使作业的优先级随着等待时间的增加而以速率a 提高，则长作业在等待一定的时间后，必然有机会分配到处理机。该优先权的变化规律可描述为：
    	Ra = (等待时间＋要求服务的时间)/要求服务的时间　＝　响应时间/要求服务的时间
    注意: 在利用这种算法时，每要进行调度之前，都需先做响应比的计算，这会增加系统开销;
    
   6. 多级反馈队列调度算法
       算法描述：
       - 进程在进入待调度的队列等待时，首先进入优先级最高的Q1等待
       - 首先调度优先级高的队列中的进程。若高优先级中队列中已没有调度的进程，则调度次优先级队列中的进程。例如：Q1,Q2,Q3三个队列，当且仅当在Q1中没有进程等待时才去调度Q2，同理，只有Q1,Q2都为空时才会去调度Q3
       - 对于同一个队列中的各个进程，按照FCFS分配时间片调度。比如Q1队列的时间片为N，那么Q1中的作业在经历了N个时间片后若还没有完成，则进入Q2队列等待，若Q2的时间片用完后作业还不能完成，一直进入下一级队列末尾，直至完成
       - 在最后一个队列QN中的各个进程，按照时间片轮转分配时间片调度
       - 在低优先级的队列中的进程在运行时，又有新到达的作业，此时须立即把正在运行的进程放回当前队列的队尾，然后把处理机分给高优先级进程。换而言之，任何时刻，只有当第1~i-1队列全部为空时，才会去执行第i队列的进程（抢占式）。特别说明，当再度运行到当前队列的该进程时，仅分配上次还未完成的时间片，不再分配该队列对应的完整时间片;
       
       举例说明:
		设有3个作业J1,J2,J3分别在时间 0 ，1，3时刻到达。而它们所需要的CPU时间分别是3，2，1个时间片。
		1. 时刻0 J1到达。于是进入到队列1 ， 运行1个时间片 ， 时间片还未到，此时J2到达;
        2. 时刻1 J2到达。 由于同一队列采用先来先服务，于是J2等待。 J1在运行了1个时间片后，已经完成了在Q1中的2个时间片的限制，于是J1置于Q2等待被调度。当前处理机分配给J2
        3. 时刻2 J1进入Q2等待调度，J2获得CPU开始运行
        4. 时刻3 J3到达，由于同一队列采用先来先服务，故J3在Q1等待调度，J1也在Q2等待调度
        5. 时刻4 J2处理完成，由于J3，J1都在等待调度，但是J3所在的队列比J1所在的队列的优先级要高，于是J3被调度，J1继续在Q2等待
        6. 时刻5 J3经过1个时间片，完成
        7. 时刻6 由于Q1已经空闲，于是开始调度Q2中的作业，则J1得到处理器开始运行。 J1再经过一个时间片，完成了任务。于是整个调度过程结束
        从上面的例子看，在多级反馈队列中，后进的作业不一定慢完成
    	
   
   两种cpu占用的方式：
    	- 可剥夺式: 就绪队列中一旦有优先级高于当前执行进程优先级的进程存在时，便立刻进行进程调度，转让处理机;
		- 不可剥夺式: 即使在就绪队列存在高于当前执行进程优先级的进程存在时，当前的进程仍将占有处理机，直到该进程自己因调用原语操作或者等待I/O进入阻塞，			　睡眠状态，或时间片用完之后才重新发生调度让出转让机；
   
    
   linux中线程调度的方式大致3种；
   - SCHED_OTHER:表示分时调度策略(也称轮转策略),是一种非实时策略，系统会为每一个线程分配一段运行时间，称为时间片
   - SCHED_FILO:先来先服务的策略，支持优先级抢占。cpu让一个先来的线程执行完在调度下一个线程，顺序就是按照创建线程的先后，线程一旦占用cpu之后就会一直运			行，直到更高优先级的任务到达或者自己放弃cpu;
   - SCHED_RR:表示时间片轮转调度策略，但是支持优先抢占，因此是一种实时的调度策略;
   

2. 进程通信有哪几种；优缺点；
    
3. new和malloc的区别
```

## 面试题目

```cpp
1. 求一个uint32位的 二进制的1 有多少位？
    int count_one(int n) {
    	int count = 0;
    	while(num) {
            ++count
            num &= (num -1); 
        }
    	return count;
	}
	#解析： num &= (num -1); 很巧妙，假设num = 0111 ,num-1= 0110,两者相&，如果num是奇数，最后一位必然是1，如果相&之后的结果不大于0，说明1的个数没有了； &之后的结果为num=0110，为偶数num-1= 0101， 那最后相邻的两位进行查看10，01，当时偶数时，两者相与必然为00，可以巧妙的计算第二位存不存在1; 然后相&的结果为 num = 0100,刚好可以判断第三位是否为0，依次类推，当num不大于0，即可统计1的个数

2. 提取一个 IP 表示的int整数；
    uint32_t ipToInt(string ip) {
    	//判断一个ip是否合法
    	if (!isIP(ip)) {
            return 0;
        }
    	
    	vector<int>ipList;
    	int len = ip.size();
    	for (int i=0; i < len; i++) {
            int j = i;
            while(j < len && ip[j] != '.') {
                j++;
            }
            ipList.push_back(atoi(ip.substr(i, j-i)));
            i = j;
        }
    
    	uint32_t res = 0;
    	int list_len = ipList.size();
    	for (int i =0 ; i < list_len; i++) {
            res = res << 8 | ipList[i];
        }
    	return res;
	}

	bool isIp(string str) {
        vector<string> str = split(str, '.');
        for (int i = 0; i < str.size(); ++i) {
			if (str.size != 4 || str[i].empty()) {
                return false;
            } else {
                if (atoi(str[i])<0 || atoi(str[i]) > 255) {
                    return false;
                }
            }
        }
        return true;
    }
    
3. 在c++中string 没有直接分割的函数，可以利用c的strtok函数封装一个分割方法
    char *strtok(char *str, const char *delim) 
    该函数返回被分解的第一个子字符串，如果没有可检索的字符串，则返回一个空指针。
    
    示例：
    1. strtok只要碰到一次delim,就会将delim替换成'\0'；
    2. 若要在第一次提取子串完毕之后，继续对源字符串s进行提取，应在其后（第二次，第三次。。。第n次）的调用中将strtok的第一个参数赋为空值NULL(表示函数继续从上一次调用隐式保存的位置，继续分解字符串；对于上述的第二次调用来说，第一次调用结束前用一个this指针指向了分界符的下一位);
	3. 如果大于两次调用，再一次传递str，而不是NULL，相当于还从字符串的开头查找分界符delim，而且此时buffer已经被修改(delim第一次被修改为了'\0'),因此是找不到delim的；
	//c++版本        
    vector<string> split(const string& str, const string& delim) {
        vector<string> res;
        if (str == "") {
            return res;
        }
        char* s = new char[str.length() + 1]; //char* 都是字符串字面值，后面都会有‘\0’;
        strcpy(s, str.c_str());
        
        char* d = new char[delim.length() + 1];
        strcpy(d, delim.c_str());
        
        char* token = strtok(s, d);
        
        while(token != NULL) {
            res.push_back(string(token);
            token = strtok(NULL, delim);
        }
        return res;
    }
	
	//c语言版本
    type define struct {
        char** res_str;
        int num;
    }splitResult;                 
    void split(char* str, char* delim, splitResult* res) {
        int count = 0;
        char* token; = strtok(str, delim);
        
        while(token != NULL) {
            ++count;
            *(res->res_str)++ = token;
            token = strtok(NULL, delim);
        }
        res->num = count;
    }
```



