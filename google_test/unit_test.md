# 单元测试的经验总结 
> 经验1
```cpp
###单元测试的好处
	对于有经验的开发写单元测试是非常有必要的，并且对自己的代码质量以及编码能力也是有提高的。单元测试可以帮助减少bug泄露，通过运行单元测试可以直接测试各个功能的正确性，bug可以提前发现并解决，由于可以跟断点，所以能够比较快的定位问题，比泄露到生产环境再定位要代价小很多。同时充足的UT是保证重构正确性的有效手段，有了足够的UT防护，才能放开手脚大胆重构已有代码，工 作多年后更了解了UT，了解了UT的重要性

### 什么是单元测试
	在敏捷的开发理念中，覆盖全面的自动化测试是添加新特性和重构的必要前提。单元测试在软件开发过程中的重要性不言而喻，特别是在测试驱动开发的开发模式越来越流行的前提下，单元测试更成为了软件开发过程中不可或缺的部分。同时单元测试也是提高软件质量，花费成本比较低的重要方法。
        
### 单元测试的时机和测试点
##单元测试的时机
	-- 在业务代码前编写单元测试采用测试驱动开发，这是我们经常使用和推荐的。
    -- 在业务代码过程中进行单元测试，对重要的业务逻辑和复杂的业务逻辑进行添加测试。
    -- 在业务逻辑之后再编写测试是我们不建议的，除非对遗留代码的修改，需要先进行测试用例的添加，保证我们修改和重构后的代码不会破坏之前的业务逻辑。
## 单元测试的测试点
    -- 在逻辑复杂的代码中添加测试。
    -- 在容易出错的地方添加测试。
    -- 不易理解的代码中添加测试，在以后看到测试就可以非常清楚代码要实现的逻辑。
    -- 在考虑后期需求变更相对较大的代码中添加测试，这样后期需求更变修改代码之后就不用太担心写的代码对不对以及是否破坏了已有代码逻辑。
    -- 外部接口处添加解耦代码、同时增加单元测试。
        
### 代码不可测试性的根源
	-- 代码中调用到了底层平台的接口或只有系统运行后才能获得的资源（数据库连接、发送邮件，网络通讯，远程服务, 文件系统等）但业务代码与这些资源未解耦。这样在测试代码需要创建这个类的时候会去初始化这些资源时导致无法测试。
	-- 在方法内部new一个与本次测试无关的对象。
    -- 代码依赖层次很深，逻辑复杂，一次方法的往往要调用N次底层的接口，或者类的方法非常多。这样的代码我们需要对类进行重构，尽量保证类的单一职责：这个类在系统中的意图应当是单一的，且修改它的原因应该只有一个。
    -- 使用单例类和静态方法，并且单例类和静态方法使用到了我们底层的接口或者其他接口。

###测试工具使用和测试方法介绍
	在做单元测试的时候，我们会发现我们要测试的方法会引用很多外部依赖的对象，如调用平台接口、连接数据库、网络通讯、远程服务、FTP、文件系统等等。 而我们没法控制这些外部依赖的对象，为了解决这个问题，我们就需要用到Mock工具来模拟这些外部依赖的对象，来完成单元测试。
        
###在下面的情况下我们可以使用Mock对象来完成单元测试。
   -- 实对象具有不可确定的行为，会产生不可预测的结果。 如：数据库查询可以查出一条记录、多条记录、或者返回数据库异常等结果。
   -- 真实对象很难被创建。如：平台代码，或者Web、JBoss容器等。
   -- 真实对象的某些行为很难触发。 如：代码中需要处理的网络异常、数据库异常、消息发送异常等。
   -- 真实情况令程序运行很慢。 在敏捷的实践中我们完成了CI，在开发提交代码前需要执行整个项目的单元测试用例，只有测试通过才可以提交代码。这就要求我们每个单元测试用例需要尽可能的短，整个项目的测试时间才会短。当有的测试用例需要测试大数据量情况下系统的预期时，就需要使用Mock对象。如我们代码中需要判断只有当系统的缓存队列大于40000时，我们开始考虑丢弃非关键的消息，当超过48000时，需要只处理最重要的消息，当超过50000时需要丢弃全部消息。此时就需要对此缓存队列进行Mock，根据调用返回不同的数据量给测试。
   -- 测试需要知道真实对象是如何被调用的。如：测试用例需要验证是否发送了JMS，此时就可以通过Mock对象是否被调用来测试。
   -- 真实对象实际不存在时。 如：当我们与其他模块交互时，或者与新的接口打交道时，更有就是对方的代码还没有开发完毕时，我们可以通过Mock来模拟接口的行为，实现代码逻辑的验证和测试。
```
> 经验2

```cpp
###什么是单元测试	
	单元测试，或者更大一些的自动化测试，对提高软件质量是有很大帮助的。通过一系列预先设计的规则，就可以覆盖大量的测试点。尤其是对重构一类的任务，确保修改前后系统行为不变很重要，而修改后的回归测试工作量又极其繁重，此时单元测试，或者自动化测试就能体现出无以伦比的效率。

单元测试设置了5个级别：
    1. Level1：正常流程可用，即一个函数在输入正确的参数时，会有正确的输出
    2. Level2：异常流程可抛出逻辑异常，即输入参数有误时，不能抛出系统异常，而是用自己定义的逻辑异常通知上层调用代码其错误之处
    3. Level3：极端情况和边界数据可用，对输入参数的边界情况也要单独测试，确保输出是正确有效的
    4. Level4：所有分支、循环的逻辑走通，不能有任何流程是测试不到的
    5. Level5：输出数据的所有字段验证，对有复杂数据结构的输出，确保每个字段都是正确的

###注意事项1
    单元测试一大痛苦是构造测试数据。我的看法是测试数据应该是人造的，而不是随便从产品环境dump出来一份。只有人造的数据能确保环境可控，每次运行不会因为环境改变而频繁修改testcase。我的常用玩法是测试数据分为基础数据和附加数据两部分。基础数据是所有testcase共享的，比如建立几个常用角色的用户等等。附加数据是testcase内部自己建立的。这样每次testcase运行时，先清空数据库，导入基础数据，导入附加数据，然后执行测试，验证结果。
    
###注意事项2
    各类程序的函数可以分为纯函数和副作用函数。纯函数对应的是数学里函数的概念，输出和输入是一一对应的。对一个输入有确定的输出。比如1+1=2。而副作用函数则相反，同样的输入，在不同时间和环境里，可能有不同的输出。比如任何涉及IO、网络、数据库的。副作用函数的测试比纯函数麻烦的多，因为你必须要完整的构造其所依赖的所有环境，才能够复现一个副作用函数的行为。也正因为如此，副作用函数出bug的概率比纯函数高的多。理解这个概念以后，应该尽可能的把程序里的纯函数和副作用函数进行拆解，降低副作用函数的比例和逻辑复杂度。还有，副作用函数是会传染的，一个函数如果调用了副作用函数，那么它也会变成副作用函数。
```

> 经验3

```cpp
	最常见的测试目标是是验证“自己写的一小段代码是不是符合设计逻辑的“。这个”一小段代码“就是我们经常说的“单元”。“单元测试”的本来意思也源自于此。比如，你写了个快排函数qsort，想验证下各种序列输入进去是不是就能得到排好序的结果。因为快排的逻辑稍微有一丢丢绕脑，觉得一遍写下来没有信心。于是就用N多的case去验证这个函数的输出是否总是符合预期。

    最常见的测试目标是是验证“自己写的一小段代码是不是符合设计逻辑的“。这个”一小段代码“就是我们经常说的“单元”。“单元测试”的本来意思也源自于此，这样的测试是最简单的，因为要测的东西几乎没有复杂的依赖。这也是大家经常说的“纯函数”好测的原因——函数的输入就是其所有可见的上下文了。对于一个纯函数，开发者者很容易构造其上下文。
        
    我们正常写的代码可能是业务逻辑，是数据分析的job代码，也有可能是前端构造界面的代码等。这种代码都会有依赖的。由于mock工具的存在，在做“单元测试”的时候，应该尽量保证除待验证的代码之外，所有的不纯的依赖都要尽量mock。有些依赖特别麻烦。比如一个例子是，验证一个下单打折的函数是否能计算出正确的折扣。这个函数需要读取数据库里的折扣数据才能做计算。这就引入一个依赖。而对依赖的处理方式的拿捏才是测试里最难的地方。
        
    比如，你可以直接mock掉整个DiscountDAO。这样就可以避免真的读取数据库。这时，你的假设是“你觉得读取折扣的SQL本身是肯定没错的，因此你不验证它，你只验证读到折扣数据后，根据输入金额得到折扣金额的逻辑是正确的
        
    你也可以用embedded数据库, h2，maria4j之类的mock数据库。但如果你生产用的是mysql/postgres等，那么你在假设“对于这一段要验证的SQL，用embedded db和用生产db是等价的“。这有可能成立，有可能不成立。但也许代码里用到了私有SQL语法，只有生产数据库支持。如果发生，这样的验证就做不了。
    你还可以用真的生产DB做验证。但首先，这里测试的目标已经变了，从“验证计算折扣的逻辑”变成“验证计算折扣这个功能是否正确“。这是已经不是“单元”了，而是一个函数 + 一句SQL执行 + DB功能正确的“集成”测试当然，这个例子里是个很局部的集成。不过也是几个组件一起测试才能实现这个验证。这样的测试代价是必须部署一个真的数据库，还要准备数据和后门。编写代价相对就比较高了。
。
        
    开发也可能做（局部）“集成测试”，所以这就是另外一个我觉得应该叫“开发阶段自动化测试“，而不仅仅是“单元测试”的原因。“单元测试“容易让人引起一个误解——开发人员只应该管一小段代码是否正确，却不用管任何集成测试。这明显是不一定正确的。比起“单元测试”这个概念本身，我更在意的是开发人员为了保证代码质量应该怎样做才对。

###那么到底要不要做这种“局部集成测试呢“。这要看情况。比如：
    -- 你的目标就是要测“一小段代码是不是正确”。你可以很有信心的保证其他依赖的正确性都能保证。那明显，这时就不用花精力做集成了。怎么简单怎么来。这样的测试甚至都不需要启动Spring这类框架，运行速度会很快。
    -- 你在开发一个小的lib。这个lib就很纯，没有任何复杂的依赖，那么单元测试就足够了。如果团队已经安排了专人做这块的集成测试，开发人员就没必要做重复劳动了。如果这块测试的不好，应该优先去和那个测试同学沟通，看看怎么改善。沟通无效，在manager知情和同意下，再自己补。
    -- 如果开发自己做集成可以更容易构造全集成测试不太容易构造的例子，那么还是自己集成测试一下比较好。性价比高。如果是要测试一个端到端的接口返回正确，那么唯一的办法就是集成测试——真的启动server，使用真的数据库、Redis、队列……，做端到端的测试。这时也许docker可以帮助你一键启动全套环境。
    -- 如果一个测试涉及到依赖的核心功能，也必须得做集成测试。比如要测试一个Exception是不是会让当前事务真的回滚，同时发生的其他事务因为隔离级别不会受到影响，那么你必须引入真的，和生产一模一样的支持事务的数据库才行。
    -- 如果是前端测试，基本上也必须得做集成测试。就算可以mock掉所有的后端接口，也得引入浏览器或者App框架才能测试。如果整个公司没有专门的测试岗位，都是“研发”，那么不管局部集成还是全部集成，都得由开发者自己上。
        
###还有个问题是什么时候应该写测试。是不是项目一开始就得同时写测试，甚至是TDD？
	Well，这也是个Case by Case的问题。单元测试也好，局部集成测试也好，都是有代价的。我的经验是，有效的开发阶段测试会占用掉开发者30%左右的精力。当然，追求技术极致的人会觉得写测试天经地义，不写才是垃圾。30%的精力也是开发的一部分，不带讨价还价的。如果覆盖率不到90%+就是不称职等等。
    我觉得不应该走极端，应该同时看到测试的成本和收益。比如在创业公司早期，就1～2个人的时候，让业务赶紧上线试错找对方向是最重要的。今天的设计和代码说不定几周后就大变样，甚至就直接丢掉了。此时功能简陋，用户量也少，小问题是可以忍的。此时团队会通过手工测试和实际使用来不断的发现和修复问题（所以这时候运行时错误log抓取 + 报警一定要做好啊）。这时强调必须完美覆盖的测试是不合时宜的。这个阶段，应该着重全集成测试（通常由一个专门的测试工程师主持），以及把那些局部的“一旦出问题公司就完蛋”的逻辑加好自动化测试。

###
	写一个新东西，有的时候一开始想不清楚设计，类、接口、模块的划分可能都不是很完美，这时写一大堆测试基本上是会废掉的。随着不断的迭代，代码的组织才能慢慢优化和清晰，这些稳固的代码产生的接口、模型才有被测试保护的意义。
    但是反过来，如果一开始图快，不写测试，随着业务慢慢稳定，团队人数和用户量慢慢多起来后，习惯性一直不写测试也是不对的。这时对代码的修改会陷入巨大的痛苦和不安中。天晓得改了一处会不会引发其他不相干代码的问题。这时，任何被心灵摧残的开发也会主动想着怎么提高代码质量的。

###
    但是最后要特别强调下，搭建有效的自动化测试的工作量并不小。一提起测试，很多人就只想到TestCase。但实际上为了让TestCase发挥作用，让测试容易运行，可以隔离，可重复，稳定的跑，需要学习和实施的东西非常多，甚至不亚于功能开发本身。对测试工作量的低估最终会导致让这个工作不了了之，变成面子工程。如果你是一个技术lead，想带领团队写测试，但以为“就是很小的工作量，随便写一下就会有效果”，那么必然会吃瘪。

###最后，我个人对【开发阶段自动化测试】的要求总结下来是：
    -- 确定测试的目标，到底想验证什么基于这个目标，找到和维护需要的工具，比如Runner，Mock，覆盖率统计工具等，Embedded数据库等
    -- 留足给测试的时间，并通过code review的手段来保证写有效的测试
    -- 给一些典型的场景如何做测试写一写文档，积累经验（比如如何测试要模拟时间的案例？）
    -- 统计测试同学给开发同学报bug的数据，盯紧代码质量不高的同学，多做沟通
    -- 根据出现bug的数量和scope来推动部分关键代码的测试质量的改善在能达成测试目标的前提下，看看能够整合一些工具，降低维护测试依赖的成本

###
    开发阶段自动化测试】是所有测试体系里的一个部分，而非全部，不能解决所有问题。不要觉得写自动化测试的Case，让覆盖率100%就能保证系统绝对不出错。这是妄想，死了这条心。
        
###ps
	也许是因为我所处的环境的缘故，我不支持TDD。因为在我处的领域，基本上不太可能出现一开始就能把设计做得很完备的情况。一个功能迭代3期就会面目全非了。
    此外TDD会导致一个趋向——面向功能开发，而非面向抽象开发。一个系统的核心是对其需求进行建模后的抽象。抽象变了，你就不能指望之前写好的接口会稳定。从系统的维护角度，长期看，要保持抽象迭代，总是能顺畅的反应业务模型最重要。    
```

